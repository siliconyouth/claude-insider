{
  "url": "https://www.anthropic.com/engineering/claude-code-best-practices",
  "title": "Claude Code Best Practices",
  "content": "Engineering at Anthropic Claude Code: Best practices for agentic coding Published Apr 18, 2025 Claude Code is a command line tool for agentic coding. This post covers tips and tricks that have proven effective for using Claude Code across various codebases, languages, and environments. We recently released Claude Code , a command line tool for agentic coding. Developed as a research project, Claude Code gives Anthropic engineers and researchers a more native way to integrate Claude into their coding workflows. Claude Code is intentionally low-level and unopinionated, providing close to raw model access without forcing specific workflows. This design philosophy creates a flexible, customizable, scriptable, and safe power tool. While powerful, this flexibility presents a learning curve for engineers new to agentic coding tools—at least until they develop their own best practices. This post outlines general patterns that have proven effective, both for Anthropic&#x27;s internal teams and for external engineers using Claude Code across various codebases, languages, and environments. Nothing in this list is set in stone nor universally applicable; consider these suggestions as starting points. We encourage you to experiment and find what works best for you! Looking for more detailed information? Our comprehensive documentation at claude.ai/code covers all the features mentioned in this post and provides additional examples, implementation details, and advanced techniques. 1. Customize your setup Claude Code is an agentic coding assistant that automatically pulls context into prompts. This context gathering consumes time and tokens, but you can optimize it through environment tuning. a. Create CLAUDE.md files CLAUDE.md is a special file that Claude automatically pulls into context when starting a conversation. This makes it an ideal place for documenting: Common bash commands Core files and utility functions Code style guidelines Testing instructions Repository etiquette (e.g., branch naming, merge vs. rebase, etc.) Developer environment setup (e.g., pyenv use, which compilers work) Any unexpected behaviors or warnings particular to the project Other information you want Claude to remember There’s no required format for CLAUDE.md files. We recommend keeping them concise and human-readable. For example: # Bash commands - npm run build: Build the project - npm run typecheck: Run the typechecker # Code style - Use ES modules (import/export) syntax, not CommonJS (require) - Destructure imports when possible (eg. import { foo } from &#x27;bar&#x27;) # Workflow - Be sure to typecheck when you’re done making a series of code changes - Prefer running single tests, and not the whole test suite, for performance Copy You can place CLAUDE.md files in several locations: The root of your repo , or wherever you run claude from (the most common usage). Name it CLAUDE.md and check it into git so that you can share it across sessions and with your team (recommended), or name it CLAUDE.local.md and .gitignore it Any parent of the directory where you run claude . This is most useful for monorepos, where you might run claude from root/foo , and have CLAUDE.md files in both root/CLAUDE.md and root/foo/CLAUDE.md . Both of these will be pulled into context automatically Any child of the directory where you run claude . This is the inverse of the above, and in this case, Claude will pull in CLAUDE.md files on demand when you work with files in child directories Your home folder ( ~/.claude/CLAUDE.md ), which applies it to all your claude sessions When you run the /init command, Claude will automatically generate a CLAUDE.md for you. b. Tune your CLAUDE.md files Your CLAUDE.md files become part of Claude’s prompts, so they should be refined like any frequently used prompt. A common mistake is adding extensive content without iterating on its effectiveness. Take time to experiment and determine what produces the best instruction following from the model. You can add content to your CLAUDE.md manually or press the # key to give Claude an instruction that it will automatically incorporate into the relevant CLAUDE.md . Many engineers use # frequently to document commands, files, and style guidelines while coding, then include CLAUDE.md changes in commits so team members benefit as well. At Anthropic, we occasionally run CLAUDE.md files through the prompt improver and often tune instructions (e.g. adding emphasis with \"IMPORTANT\" or \"YOU MUST\") to improve adherence. c. Curate Claude&#x27;s list of allowed tools By default, Claude Code requests permission for any action that might modify your system: file writes, many bash commands, MCP tools, etc. We designed Claude Code with this deliberately conservative approach to prioritize safety. You can customize the allowlist to permit additional tools that you know are safe, or to allow potentially unsafe tools that are easy to undo (e.g., file editing, git commit ). There are four ways to manage allowed tools: Select \"Always allow\" when prompted during a session. Use the /permissions command after starting Claude Code to add or remove tools from the allowlist. For example, you can add Edit to always allow file edits, Bash(git commit:*) to allow git commits, or mcp__puppeteer__puppeteer_navigate to allow navigating with the Puppeteer MCP server. Manually edit your .claude/settings.json or ~/.claude.json (we recommend checking the former into source control to share with your team) . Use the --allowedTools CLI flag for session-specific permissions. d. If using GitHub, install the gh CLI Claude knows how to use the gh CLI to interact with GitHub for creating issues, opening pull requests, reading comments, and more. Without gh installed, Claude can still use the GitHub API or MCP server (if you have it installed). 2. Give Claude more tools Claude has access to your shell environment, where you can build up sets of convenience scripts and functions for it just like you would for yourself. It can also leverage more complex tools through MCP and REST APIs. a. Use Claude with bash tools Claude Code inherits your bash environment, giving it access to all your tools. While Claude knows common utilities like unix tools and gh , it won&#x27;t know about your custom bash tools without instructions: Tell Claude the tool name with usage examples Tell Claude to run --help to see tool documentation Document frequently used tools in CLAUDE.md b. Use Claude with MCP Claude Code functions as both an MCP server and client. As a client, it can connect to any number of MCP servers to access their tools in three ways: In project config (available when running Claude Code in that directory) In global config (available in all projects) In a checked-in .mcp.json file (available to anyone working in your codebase). For example, you can add Puppeteer and Sentry servers to your .mcp.json , so that every engineer working on your repo can use these out of the box. When working with MCP, it can also be helpful to launch Claude with the --mcp-debug flag to help identify configuration issues. c. Use custom slash commands For repeated workflows—debugging loops, log analysis, etc.—store prompt templates in Markdown files within the .claude/commands folder. These become available through the slash commands menu when you type / . You can check these commands into git to make them available for the rest of your team. Custom slash commands can include the special keyword $ARGUMENTS to pass parameters from command invocation. For example, here’s a slash command that you could use to automatically pull and fix a Github issue: Please analyze and fix the GitHub issue: $ARGUMENTS. Follow these steps: 1. Use `gh issue view` to get the issue details 2. Understand the problem described in the issue 3. Search the codebase for relevant files 4. Implement the necessary changes to fix the issue 5. Write and run tests to verify the fix 6. Ensure code passes linting and type checking 7. Create a descriptive commit message 8. Push and create a PR Remember to use the GitHub CLI (`gh`) for all GitHub-related tasks. Copy Putting the above content into .claude/commands/fix-github-issue.md makes it available as the /project:fix-github-issue command in Claude Code. You could then for example use /project:fix-github-issue 1234 to have Claude fix issue #1234. Similarly, you can add your own personal commands to the ~/.claude/commands folder for commands you want available in all of your sessions. 3. Try common workflows Claude Code doesn’t impose a specific workflow, giving you the flexibility to use it how you want. Within the space this flexibility affords, several successful patterns for effectively using Claude Code have emerged across our community of users: a. Explore, plan, code, commit This versatile workflow suits many problems: Ask Claude to read relevant files, images, or URLs , providing either general pointers (\"read the file that handles logging\") or specific filenames (\"read logging.py\"), but explicitly tell it not to write any code just yet. This is the part of the workflow where you should consider strong use of subagents, especially for complex problems. Telling Claude to use subagents to verify details or investigate particular questions it might have, especially early on in a conversation or task, tends to preserve context availability without much downside in terms of lost efficiency. Ask Claude to make a plan for how to approach a specific problem . We recommend using the word \"think\" to trigger extended thinking mode, which gives Claude additional computation time to evaluate alternatives more thoroughly. These specific phrases are mapped directly to increasing levels of thinking budget in the system: \"think\" < \"think hard\" < \"think harder\" < \"ultrathink.\" Each level allocates progressively more thinking budget for Claude to use. If the results of this step seem reasonable, you can have Claude create a document or a GitHub issue with its plan so that you can reset to this spot if the implementation (step 3) isn’t what you want. Ask Claude to implement its solution in code . This is also a good place to ask it to explicitly verify the reasonableness of its solution as it implements pieces of the solution. Ask Claude to commit the result and create a pull request . If relevant, this is also a good time to have Claude update any READMEs or changelogs with an explanation of what it just did. Steps #1-#2 are crucial—without them, Claude tends to jump straight to coding a solution. While sometimes that&#x27;s what you want, asking Claude to research and plan first significantly improves performance for problems requiring deeper thinking upfront. b. Write tests, commit; code, iterate, commit This is an Anthropic-favorite workflow for changes that are easily verifiable with unit, integration, or end-to-end tests. Test-driven development (TDD) becomes even more powerful with agentic coding: Ask Claude to write tests based on expected input/output pairs . Be explicit about the fact that you’re doing test-driven development so that it avoids creating mock implementations, even for functionality that doesn’t exist yet in the codebase. Tell Claude to run the tests and confirm they fail . Explicitly telling it not to write any implementation code at this stage is often helpful. Ask Claude to commit the tests when you’re satisfied with them. Ask Claude to write code that passes the tests , instructing it not to modify the tests. Tell Claude to keep going until all tests pass. It will usually take a few iterations for Claude to write code, run the tests, adjust the code, and run the tests again. At this stage, it can help to ask it to verify with independent subagents that the implementation isn’t overfitting to the tests Ask Claude to commit the code once you’re satisfied with the changes. Claude performs best when it has a clear target to iterate against—a visual mock, a test case, or another kind of output. By providing expected outputs like tests, Claude can make changes, evaluate results, and incrementally improve until it succeeds. c. Write code, screenshot result, iterate Similar to the testing workflow, you can provide Claude with visual targets: Give Claude a way to take browser screenshots (e.g., with the Puppeteer MCP server , an iOS simulator MCP server , or manually copy / paste screenshots into Claude). Give Claude a visual mock by copying / pasting or drag-dropping an image, or giving Claude the image file path. Ask Claude to implement the design in code, take screenshots of the result, and iterate until its result matches the mock. Ask Claude to commit when you&#x27;re satisfied. Like humans, Claude&#x27;s outputs tend to improve significantly with iteration. While the first version might be good, after 2-3 iterations it will typically look much better. Give Claude the tools to see its outputs for best results. d. Safe YOLO mode Instead of supervising Claude, you can use claude --dangerously-skip-permissions to bypass all permission checks and let Claude work uninterrupted until completion. This works well for workflows like fixing lint errors or generating boilerplate code. Letting Claude run arbitrary commands is risky and can result in data loss, system corruption, or even data exfiltration (e.g., via prompt injection attacks). To minimize these risks, use --dangerously-skip-permissions in a container without internet access. You can follow this reference implementation using Docker Dev Containers. e. Codebase Q&A When onboarding to a new codebase, use Claude Code for learning and exploration. You can ask Claude the same sorts of questions you would ask another engineer on the project when pair programming. Claude can agentically search the codebase to answer general questions like: How does logging work? How do I make a new API endpoint? What does async move { ... } do on line 134 of foo.rs ? What edge cases does CustomerOnboardingFlowImpl handle? Why are we calling foo() instead of bar() on line 333? What’s the equivalent of line 334 of baz.py in Java? At Anthropic, using Claude Code in this way has become our core onboarding workflow, significantly improving ramp-up time and reducing load on other engineers. No special prompting is required! Simply ask questions, and Claude will explore the code to find answers. f. Use Claude to interact with git Claude can effectively handle many git operations. Many Anthropic engineers use Claude for 90%+ of our git interactions: Searching git history to answer questions like \"What changes made it into v1.2.3?\", \"Who owns this particular feature?\", or \"Why was this API designed this way?\" It helps to explicitly prompt Claude to look through git history to answer queries like these. Writing commit messages . Claude will look at your changes and recent history automatically to compose a message taking all the relevant context into account Handling complex git operations like reverting files, resolving r...",
  "summary": "# Claude Code Best Practices - Documentation Summary\n\n## Overview\nThis document covers best practices for using Claude Code, Anthropic's command-line agentic coding tool. It emphasizes that Claude Code is intentionally low-level and unopinionated, providing flexible, customizable, and scriptable access to Claude for coding workflows.\n\n## Main Topics\n\n### 1. Customizing Your Setup\n\n#### CLAUDE.md Files\n**Purpose**: Special files automatically pulled into context when starting conversations. Used for documenting project-specific information.\n\n**Recommended Content**:\n- Common bash commands\n- Core files and utility functions\n- Code style guidelines\n- Testing instructions\n- Repository etiquette (branch naming, merge vs. rebase)\n- Developer environment setup (pyenv, compilers)\n- Unexpected behaviors or warnings\n- Any information you want Claude to remember\n\n**File Locations** (in order of specificity):\n| Location | Behavior |\n|----------|----------|\n| Repository root (where `claude` runs) | Most common usage |\n| Parent directories | Useful for monorepos; both parent and child CLAUDE.md files are pulled in |\n| Child directories | Pulled in on-demand when working with files in those directories |\n| `~/.claude/CLAUDE.md` | Applies to all Claude sessions globally |\n\n**Naming Conventions**:\n- `CLAUDE.md` - Check into git to share with team (recommended)\n- `CLAUDE.local.md` - Add to .gitignore for personal use\n\n**Example CLAUDE.md**:\n```markdown\n# Bash commands\n- npm run build: Build the project\n- npm run typecheck: Run the typechecker\n\n# Code style\n- Use ES modules (import/export) syntax, not CommonJS (require)\n- Destructure imports when possible (eg. import { foo } from 'bar')\n\n# Workflow\n- Be sure to typecheck when you're done making a series of code changes\n- Prefer running single tests, and not the whole test suite, for performance\n```\n\n**Commands**:\n- `/init` - Automatically generates a CLAUDE.md file\n- `#` key - Give Claude instructions to automatically incorporate into relevant CLAUDE.md\n\n#### Tool Permissions Management\n\n**Default Behavior**: Claude Code requests permission for system-modifying actions (file writes, bash commands, MCP tools).\n\n**Four Ways to Manage Allowed Tools**:\n1. Select \"Always allow\" when prompted during session\n2. Use `/permissions` command to add/remove tools\n3. Manually edit `.claude/settings.json` (project) or `~/.claude.json` (global)\n4. Use `--allowedTools` CLI flag for session-specific permissions\n\n**Permission Examples**:\n- `Edit` - Always allow file edits\n- `Bash(git commit:*)` - Allow git commits\n- `mcp__puppeteer__puppeteer_navigate` - Allow Puppeteer MCP navigation\n\n**Best Practice**: Check `.claude/settings.json` into source control to share with team.\n\n#### GitHub Integration\n- Install `gh` CLI for Claude to interact with GitHub\n- Capabilities: creating issues, opening PRs, reading comments\n- Alternative: GitHub API or MCP server if gh not installed\n\n---\n\n### 2. Extending Claude with Additional Tools\n\n#### Bash Tools\n- Claude inherits your bash environment\n- Claude knows common utilities (unix tools, gh)\n- For custom tools: tell Claude the tool name with examples, or instruct it to run `--help`\n- Document frequently used tools in CLAUDE.md\n\n#### MCP (Model Context Protocol) Integration\n**Claude Code can act as both MCP server and client.**\n\n**Three Configuration Methods**:\n1. Project config (available in specific directory)\n2. Global config (available in all projects)\n3. Checked-in `.mcp.json` file (available to all repo contributors)\n\n**Debugging**: Use `--mcp-debug` flag to identify configuration issues\n\n**Example Use Case**: Add Puppeteer and Sentry servers to `.mcp.json` for team-wide access\n\n#### Custom Slash Commands\n**Location**: Store prompt templates in `.claude/commands/` folder as Markdown files\n\n**Features**:\n- Accessible via `/` menu\n- Can be checked into git for team sharing\n- Support `$ARGUMENTS` keyword for parameter passing\n\n**Example Slash Command** (GitHub issue fixer):\n```markdown\nPlease analyze and fix the GitHub issue: $ARGUMENTS.\n\nFollow these steps:\n1. Use `gh issue view` to get the issue details\n2. Understand the problem described in the issue\n3. Search the codebase for relevant files\n4. Implement the necessary changes to fix the issue\n5. Write and run tests to verify the fix\n6. Ensure code passes linting and type checking\n7. Create\n```\n*(Note: Example appears truncated in source)*\n\n---\n\n## Key Commands Reference\n\n| Command/Flag | Purpose |\n|--------------|---------|\n| `/init` | Auto-generate CLAUDE.md |\n| `/permissions` | Manage tool allowlist |\n| `#` | Add instruction to CLAUDE.md |\n| `/` | Access slash commands menu |\n| `--allowedTools` | Session-specific permissions |\n| `--mcp-debug` | Debug MCP configuration |\n\n## Configuration Files\n\n| File | Scope | Purpose |\n|------|-------|---------|\n| `CLAUDE.md` | Project | Shared project context (check into git) |\n| `CLAUDE.local.md` | Project | Personal project context (gitignore) |\n| `~/.claude/CLAUDE.md` | Global | User-wide context |\n| `.claude/settings.json` | Project | Project permissions (can share via git) |\n| `~/.claude.json` | Global | Global settings |\n| `.mcp.json` | Project | MCP server configuration (shareable) |\n| `.claude/commands/*.md` | Project | Custom slash commands |\n\n## Best Practices & Recommendations\n\n1. **Keep CLAUDE.md concise and human-readable**\n2. **Iterate on CLAUDE.md content** - treat it like a frequently used prompt\n3. **Use prompt improver tools** on CLAUDE.md files\n4. **Add emphasis** (\"IMPORTANT\", \"YOU MUST\") to improve instruction adherence\n5. **Share configurations** - check CLAUDE.md and .claude/settings.json into version control\n6. **Document as you code** - use `#` to add discoveries to CLAUDE.md during sessions\n7. **Include CLAUDE.md changes in commits** so team members benefit\n\n## Caveats & Warnings\n\n1. **Learning curve** exists for engineers new to agentic coding tools\n2. **Context gathering consumes time and tokens** - optimize through environment tuning\n3. **Nothing is universally applicable** - these are starting points, experiment to find what works\n4. **Conservative permission defaults** are intentional for safety\n5. **Common mistake**: Adding extensive CLAUDE.md content without iterating on effectiveness\n\n## Additional Resources\n- Comprehensive documentation: `claude.ai/code`\n- Publication date: April 18, 2025",
  "referencedFrom": [
    "configuration/claude-md.mdx",
    "configuration/index.mdx",
    "getting-started/quickstart.mdx",
    "integrations/hooks.mdx",
    "tips-and-tricks/index.mdx",
    "tips-and-tricks/productivity.mdx",
    "tips-and-tricks/prompting.mdx"
  ],
  "cachedAt": "2025-12-13T18:35:26.714Z",
  "contentLength": 15003,
  "summaryLength": 6383,
  "model": "claude-opus-4-5-20251101"
}