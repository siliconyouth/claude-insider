{
  "url": "https://www.w3.org/TR/webauthn-2/",
  "title": "WebAuthn Specification",
  "content": "1. Introduction This section is not normative. This specification defines an API enabling the creation and use of strong, attested, scoped , public key-based credentials by web applications , for the purpose of strongly authenticating users. A public key credential is created and stored by a WebAuthn Authenticator at the behest of a WebAuthn Relying Party , subject to user consent . Subsequently, the public key credential can only be accessed by origins belonging to that Relying Party . This scoping is enforced jointly by conforming User Agents and authenticators . Additionally, privacy across Relying Parties is maintained; Relying Parties are not able to detect any properties, or even the existence, of credentials scoped to other Relying Parties . Relying Parties employ the Web Authentication API during two distinct, but related, ceremonies involving a user. The first is Registration , where a public key credential is created on an authenticator , and scoped to a Relying Party with the present user’s account (the account might already exist or might be created at this time). The second is Authentication , where the Relying Party is presented with an Authentication Assertion proving the presence and consent of the user who registered the public key credential . Functionally, the Web Authentication API comprises a PublicKeyCredential which extends the Credential Management API [CREDENTIAL-MANAGEMENT-1] , and infrastructure which allows those credentials to be used with navigator.credentials.create() and navigator.credentials.get() . The former is used during Registration , and the latter during Authentication . Broadly, compliant authenticators protect public key credentials , and interact with user agents to implement the Web Authentication API . Implementing compliant authenticators is possible in software executing (a) on a general-purpose computing device, (b) on an on-device Secure Execution Environment, Trusted Platform Module (TPM), or a Secure Element (SE), or (c) off device. Authenticators being implemented on device are called platform authenticators . Authenticators being implemented off device ( roaming authenticators ) can be accessed over a transport such as Universal Serial Bus (USB), Bluetooth Low Energy (BLE), or Near Field Communications (NFC). 1.1. Specification Roadmap While many W3C specifications are directed primarily to user agent developers and also to web application developers (i.e., \"Web authors\"), the nature of Web Authentication requires that this specification be correctly used by multiple audiences, as described below. All audiences ought to begin with § 1.2 Use Cases , § 1.3 Sample API Usage Scenarios , and § 4 Terminology , and should also refer to [WebAuthnAPIGuide] for an overall tutorial. Beyond that, the intended audiences for this document are the following main groups: Relying Party web application developers, especially those responsible for Relying Party web application login flows, account recovery flows, user account database content, etc. Web framework developers The above two audiences should in particular refer to § 7 WebAuthn Relying Party Operations . The introduction to § 5 Web Authentication API may be helpful, though readers should realize that the § 5 Web Authentication API section is targeted specifically at user agent developers, not web application developers. Additionally, if they intend to verify authenticator attestations , then § 6.5 Attestation and § 8 Defined Attestation Statement Formats will also be relevant. § 9 WebAuthn Extensions , and § 10 Defined Extensions will be of interest if they wish to make use of extensions. Finally, they should read § 13.4 Security considerations for Relying Parties and § 14.6 Privacy considerations for Relying Parties and consider which challenges apply to their application and users. User agent developers OS platform developers, responsible for OS platform API design and implementation in regards to platform-specific authenticator APIs, platform WebAuthn Client instantiation, etc. The above two audiences should read § 5 Web Authentication API very carefully, along with § 9 WebAuthn Extensions if they intend to support extensions. They should also carefully read § 14.5 Privacy considerations for clients . Authenticator developers. These readers will want to pay particular attention to § 6 WebAuthn Authenticator Model , § 8 Defined Attestation Statement Formats , § 9 WebAuthn Extensions , and § 10 Defined Extensions . They should also carefully read § 13.3 Security considerations for authenticators and § 14.4 Privacy considerations for authenticators . Note: Along with the Web Authentication API itself, this specification defines a request-response cryptographic protocol —the WebAuthn/FIDO2 protocol —between a WebAuthn Relying Party server and an authenticator , where the Relying Party 's request consists of a challenge and other input data supplied by the Relying Party and sent to the authenticator . The request is conveyed via the combination of HTTPS, the Relying Party web application , the WebAuthn API , and the platform-specific communications channel between the user agent and the authenticator . The authenticator replies with a digitally signed authenticator data message and other output data, which is conveyed back to the Relying Party server via the same path in reverse. Protocol details vary according to whether an authentication or registration operation is invoked by the Relying Party . See also Figure 1 and Figure 2 . It is important for Web Authentication deployments' end-to-end security that the role of each component—the Relying Party server, the client , and the authenticator — as well as § 13 Security Considerations and § 14 Privacy Considerations , are understood by all audiences . 1.2. Use Cases The below use case scenarios illustrate use of two very different types of authenticators , as well as outline further scenarios. Additional scenarios, including sample code, are given later in § 1.3 Sample API Usage Scenarios . 1.2.1. Registration On a phone: User navigates to example.com in a browser and signs in to an existing account using whatever method they have been using (possibly a legacy method such as a password), or creates a new account. The phone prompts, \"Do you want to register this device with example.com?\" User agrees. The phone prompts the user for a previously configured authorization gesture (PIN, biometric, etc.); the user provides this. Website shows message, \"Registration complete.\" 1.2.2. Authentication On a laptop or desktop: User pairs their phone with the laptop or desktop via Bluetooth. User navigates to example.com in a browser and initiates signing in. User gets a message from the browser, \"Please complete this action on your phone.\" Next, on their phone: User sees a discrete prompt or notification, \"Sign in to example.com.\" User selects this prompt / notification. User is shown a list of their example.com identities, e.g., \"Sign in as Mohamed / Sign in as 张三\". User picks an identity, is prompted for an authorization gesture (PIN, biometric, etc.) and provides this. Now, back on the laptop: Web page shows that the selected user is signed in, and navigates to the signed-in page. 1.2.3. New Device Registration This use case scenario illustrates how a Relying Party can leverage a combination of a roaming authenticator (e.g., a USB security key fob) and a platform authenticator (e.g., a built-in fingerprint sensor) such that the user has: a \"primary\" roaming authenticator that they use to authenticate on new-to-them client devices (e.g., laptops, desktops) or on such client devices that lack a platform authenticator , and a low-friction means to strongly re-authenticate on client devices having platform authenticators . Note: This approach of registering multiple authenticators for an account is also useful in account recovery use cases. First, on a desktop computer (lacking a platform authenticator ): User navigates to example.com in a browser and signs in to an existing account using whatever method they have been using (possibly a legacy method such as a password), or creates a new account. User navigates to account security settings and selects \"Register security key\". Website prompts the user to plug in a USB security key fob; the user does. The USB security key blinks to indicate the user should press the button on it; the user does. Website shows message, \"Registration complete.\" Note: Since this computer lacks a platform authenticator , the website may require the user to present their USB security key from time to time or each time the user interacts with the website. This is at the website’s discretion. Later, on their laptop (which features a platform authenticator ): User navigates to example.com in a browser and initiates signing in. Website prompts the user to plug in their USB security key. User plugs in the previously registered USB security key and presses the button. Website shows that the user is signed in, and navigates to the signed-in page. Website prompts, \"Do you want to register this computer with example.com?\" User agrees. Laptop prompts the user for a previously configured authorization gesture (PIN, biometric, etc.); the user provides this. Website shows message, \"Registration complete.\" User signs out. Later, again on their laptop: User navigates to example.com in a browser and initiates signing in. Website shows message, \"Please follow your computer’s prompts to complete sign in.\" Laptop prompts the user for an authorization gesture (PIN, biometric, etc.); the user provides this. Website shows that the user is signed in, and navigates to the signed-in page. 1.2.4. Other Use Cases and Configurations A variety of additional use cases and configurations are also possible, including (but not limited to): A user navigates to example.com on their laptop, is guided through a flow to create and register a credential on their phone. A user obtains a discrete, roaming authenticator , such as a \"fob\" with USB or USB+NFC/BLE connectivity options, loads example.com in their browser on a laptop or phone, and is guided through a flow to create and register a credential on the fob. A Relying Party prompts the user for their authorization gesture in order to authorize a single transaction, such as a payment or other financial transaction. 1.3. Sample API Usage Scenarios This section is not normative. In this section, we walk through some events in the lifecycle of a public key credential , along with the corresponding sample code for using this API. Note that this is an example flow and does not limit the scope of how the API can be used. As was the case in earlier sections, this flow focuses on a use case involving a first-factor roaming authenticator with its own display. One example of such an authenticator would be a smart phone. Other authenticator types are also supported by this API, subject to implementation by the client platform . For instance, this flow also works without modification for the case of an authenticator that is embedded in the client device . The flow also works for the case of an authenticator without its own display (similar to a smart card) subject to specific implementation considerations. Specifically, the client platform needs to display any prompts that would otherwise be shown by the authenticator, and the authenticator needs to allow the client platform to enumerate all the authenticator’s credentials so that the client can have information to show appropriate prompts. 1.3.1. Registration This is the first-time flow, in which a new credential is created and registered with the server. In this flow, the WebAuthn Relying Party does not have a preference for platform authenticator or roaming authenticators . The user visits example.com, which serves up a script. At this point, the user may already be logged in using a legacy username and password, or additional authenticator, or other means acceptable to the Relying Party . Or the user may be in the process of creating a new account. The Relying Party script runs the code snippet below. The client platform searches for and locates the authenticator. The client connects to the authenticator, performing any pairing actions if necessary. The authenticator shows appropriate UI for the user to provide a biometric or other authorization gesture . The authenticator returns a response to the client , which in turn returns a response to the Relying Party script. If the user declined to select an authenticator or provide authorization, an appropriate error is returned. If a new credential was created, The Relying Party script sends the newly generated credential public key to the server, along with additional information such as attestation regarding the provenance and characteristics of the authenticator. The server stores the credential public key in its database and associates it with the user as well as with the characteristics of authentication indicated by attestation, also storing a friendly name for later use. The script may store data such as the credential ID in local storage, to improve future UX by narrowing the choice of credential for the user. The sample code for generating and registering a new key follows: if ( ! window . PublicKeyCredential ) { /* Client not capable. Handle error. */ } var publicKey = { // The challenge is produced by the server; see the Security Considerations challenge : new Uint8Array ([ 21 , 31 , 105 /* 29 more random bytes generated by the server */ ]), // Relying Party: rp : { name : \"ACME Corporation\" }, // User: user : { id : Uint8Array . from ( window . atob ( \"MIIBkzCCATigAwIBAjCCAZMwggE4oAMCAQIwggGTMII=\" ), c => c . charCodeAt ( 0 )), name : \"alex.mueller@example.com\" , displayName : \"Alex Müller\" , }, // This Relying Party will accept either an ES256 or RS256 credential, but // prefers an ES256 credential. pubKeyCredParams : [ { type : \"public-key\" , alg : - 7 // \"ES256\" as registered in the IANA COSE Algorithms registry }, { type : \"public-key\" , alg : - 257 // Value registered by this specification for \"RS256\" } ], authenticatorSelection : { // Try to use UV if possible. This is also the default. userVerification : \"preferred\" }, timeout : 360000 , // 6 minutes excludeCredentials : [ // Don’t re-register any authenticator that has one of these credentials { \"id\" : Uint8Array . from ( window . atob ( \"ufJWp8YGlibm1Kd9XQBWN1WAw2jy5In2Xhon9HAqcXE=\" ), c => c . charCodeAt ( 0 )), \"type\" : \"public-key\" }, { \"id\" : Uint8Array . from ( window . atob ( \"E/e1dhZc++mIsz4f9hb6NifAzJpF1V4mEtRlIPBiWdY=\" ), c => c . charCodeAt ( 0 )), \"type\" : \"public-key\" } ], // Make excludeCredentials check backwards compatible with credentials registered with U2F extensions : { \"appidExclude\" : \"https://acme.example.com\" } }; // Note: The following call will cause the authenticator to display UI. navigator . credentials . create ({ publicKey }) . then ( function ( newCredentialInfo ) { // Send new credential info to server for verification and registration. }). catch ( function ( err ) { // No acceptable authenticator or user refused consent. Handle appropriately. }); 1.3.2. Registration Specifically with User-Verifying Platform Authenticator This is an example flow for when the WebAuthn Relying Party is specifically interested in creating a public key credential with a user-verifying platform authenticator . The user visits example.com and clicks on the login button, which redirects the user to login.example.com. The user enters a username and password to log in. After successful login, the user is redirected back to example.com. The Relying Party script runs the code snippet below. The user agent checks if a user-verifying platform authenticator is available. If not, terminate this flow. The Relying Party asks the user if they want to create a credential with it. If not, terminate this flow. The user agent and/or operating system shows appropriate UI and guides the user in creating a credential using one of the available platform authenticators. Upon successful credential creation, the Relying Party script conveys the new credential to the server. if ( ! window . PublicKeyCredential ) { /* Client not capable of the API. Handle error. */ } PublicKeyCredential . isUserVerifyingPlatformAuthenticatorAvailable () . then ( function ( uvpaAvailable ) { // If there is a user-verifying platform authenticator if ( uvpaAvailable ) { // Render some RP-specific UI and get a Promise for a Boolean value return askIfUserWantsToCreateCredential (); } }). then ( function ( userSaidYes ) { // If there is a user-verifying platform authenticator // AND the user wants to create a credential if ( userSaidYes ) { var publicKeyOptions = { /* Public key credential creation options. */ }; return navigator . credentials . create ({ \"publicKey\" : publicKeyOptions }); } }). then ( function ( newCredentialInfo ) { if ( newCredentialInfo ) { // Send new credential info to server for verification and registration. } }). catch ( function ( err ) { // Something went wrong. Handle appropriately. }); 1.3.3. Authentication This is the flow when a user with an already registered credential visits a website and wants to authenticate using the credential. The user visits example.com, which serves up a script. The script asks the client for an Authentication Assertion, providing as much information as possible to narrow the choice of acceptable credentials for the user. This can be obtained from the data that was stored locally after registration, or by other means such as prompting the user for a username. The Relying Party script runs one of the code snippets below. The client platform searches for and locates the authenticator. The client connects to the authenticator, performing any pairing actions if necessary. The authenticator presents the user with a notification that their attention is needed. On opening the notification, the user is shown a friendly selection menu of acceptable credentials using the account information provided when creating the credentials, along with some information on the origin that is requesting these keys. The authenticator obtains a biometric or other authorization gesture from the user. The authenticator returns a response to the client , which in turn returns a response to the Relying Party script. If the user declined to select a credential or provide an authorization, an appropriate error is returned. If an assertion was successfully generated and returned, The script sends the assertion to the server. The server examines the assertion, extracts the credential ID , looks up the registered credential public key in its database, and verifies the assertion signature . If valid, it looks up the identity associated with the assertion’s credential ID ; that identity is now authenticated. If the credential ID is not recognized by the server (e.g., it has been deregistered due to inactivity) then the authentication has failed; each Relying Party will handle this in its own way. The server now does whatever it would otherwise do upon successful authentication -- return a success page, set authentication cookies, etc. If the Relying Party script does not have any hints available (e.g., from locally stored data) to help it narrow the list of credentials, then the sample code for performing such an authentication might look like this: if ( ! window . PublicKeyCredential ) { /* Client not capable. Handle error. */ } // credentialId is generated by the authenticator and is an opaque random byte array var credentialId = new Uint8Array ([ 183 , 148 , 245 /* more random bytes previously generated by the authenticator */ ]); var options = { // The challenge is produced by the server; see the Security Considerations challenge : new Uint8Array ([ 4 , 101 , 15 /* 29 more random bytes generated by the server */ ]), timeout : 120000 , // 2 minutes allowCredentials : [{ type : \"public-key\" , id : credentialId }] }; navigator . credentials . get ({ \"publicKey\" : options }) . then ( function ( assertion ) { // Send assertion to server for verification }). catch ( function ( err ) { // No acceptable credential or user refused consent. Handle appropriately. }); On the other hand, if the Relying Party script has some hints to help it narrow the list of credentials, then the sample code for performing such an authentication might look like the following. Note that this sample also demonstrates how to use the Credential Properties Extension . if ( ! window . PublicKeyCredential ) { /* Client not capable. Handle error. */ } var encoder = new TextEncoder (); var acceptableCredential1 = { type : \"public-key\" , id : encoder . encode ( \"BA44712732CE\" ) }; var acceptableCredential2 = { type : \"public-key\" , id : encoder . encode ( \"BG35122345NF\" ) }; var options = { // The challenge is produced by the server; see the Security Considerations challenge : new Uint8Array ([ 8 , 18 , 33 /* 29 more random bytes generated by the server */ ]), timeout : 120000 , // 2 minutes allowCredentials : [ acceptableCredential1 , acceptableCredential2 ], extensions : { 'credProps' : true } }; navigator . credentials . get ({ \"publicKey\" : options }) . then ( function ( assertion ) { // Send assertion to server for verification }). catch ( function ( err ) { // No acceptable credential or user refused consent. Handle appropriately. }); 1.3.4. Aborting Authentication Operations The below example shows how a developer may use the AbortSignal parameter to abort a credential registration operation. A similar procedure applies to an authentication operation. const authAbortController = new AbortController (); const authAbortSignal = authAbortController . signal ; authAbortSignal . onabort = function () { // Once the page knows the abort started, inform user it is attempting to abort. } var options = { // A list of options. } navigator . credentials . create ({ publicKey : options , signal : authAbortSignal }) . then ( function ( attestation ) { // Register the user. }). catch ( function ( error ) { if ( error == \"AbortError\" ) { // Inform user the credential hasn’t been created. // Let the server know a key hasn’t been created. } }); // Assume widget shows up whenever authentication occurs. if ( widget == \"disappear\" ) { authAbortController . abort (); } 1.3.5. Decommissioning The following are possible situations in which decommissioning a credential might be desired. Note that all of these are handled on the server side and do not need support from the API specified here. Possibility #1 -- user reports the credential as lost. User goes to server.example.net, authenticates and follows a link to report a lost/stolen authenticator . Server returns a page showing the list of registered credentials with friendly names as configured during registration. User selects a credential and the server deletes it from its database. In the future, the Relying Party script does not specify this credential in any list of acceptable credentials, and assertions signed by this credential are rejected. Possibility #2 -- server deregisters the credential due to inactivity. Server deletes credential from its database during maintenance activity. In the future, the Relying Party script does not specify this credential in any list of acceptable credentials, and assertions signed by this credential are rejected. Possibility #3 -- user deletes the credential from the authenticator . User employs a authenticator -specific method (e.g., device settings UI) to delete a credential from their authenticator . From this point on, this credential will not appear in any selection prompts, and no assertions can be generated with it. Sometime later, the server deregisters this credential due to inactivity. 1.4. Platform-Specific Implementation Guidance This specification defines how to use Web Authentication in the general case. When using Web Authentication in connection with specific platform support (e.g. apps), it is recommended to see platform-specific documentation and guides for additional guidance and limitations. 2. Conformance This specification defines three conformance classes. Each of these classes is specified so that conforming members of the class are secure against non-conforming or hostile members of the other classes. 2.1. User Agents A User Agent MUST behave as described by § 5 Web Authentication API in order to be considered conformant. Conforming User Agents MAY implement algorithms given in this specification in any way desired, so long as the end result is indistinguishable from the result that would be obtained by the specification’s algorithms. A conforming User Agent MUST also be a conforming implementation of the IDL fragments of this specification, as described in the “Web IDL” specification. [WebIDL] 2.1.1. Enumerations as DOMString types Enumeration types are not referenced by other parts of the Web IDL because that would preclude other values from being used without updating this specification and its implementations. It is important for backwards compatibility that client platforms and Relying Parties handle unknown values. Enumerations for this specification exist here for documentation and as a registry. Where the enumerations are represented elsewhere, they are typed as DOMString s, for example in transports . 2.2. Authenticators A WebAuthn Authenticator MUST provide the operations defined by § 6 WebAuthn Authenticator Model , and those operations MUST behave as described there. This is a set of functional and security requirements for an authenticator to be usable by a Conforming User Agent . As described in § 1.2 Use Cases , an authenticator may be implemented in the operating system underlying the User Agent, or in external hardware, or a combination of both. 2.2.1. Backwards Compatibility with FIDO U2F Authenticators that only support the § 8.6 FIDO U2F Attestation Statement Format have no mechanism to store a user handle , so the returned userHandle will always be null. 2.3. WebAuthn Relying Parties A WebAuthn Relying Party MUST behave as described in § 7 WebAuthn Relying Party Operations to obtain all the security benefits offered by this specification. See § 13.4.1 Security Benefits for WebAuthn Relying Parties for further discussion of this. 2.4. All Conformance Classes All CBOR encoding performed by the members of the above conformance classes MUST be done using the CTAP2 canonical CBOR encoding form . All decoders of the above conformance classes SHOULD reject CBOR that is not validly encoded in the CTAP2 canonical CBOR encoding form and SHOULD reject messages with duplicate map keys. 3. Dependencies This specification relies on several other underlying specifications, listed below and in Terms defined by reference . Base64url encoding The term Base64url Encoding refers to the base64 encoding using the URL- and filename-safe character set defined in Section 5 of [RFC4648] , with all trailing '=' characters omitted (as permitted by Section 3.2) and without the inclusion of any line breaks, whitespace, or other additional characters. CBOR A number of structures in this specification, including attestation statements and extensions, are encoded using the CTAP2 canonical CBOR encoding form of the Compact Binary Object Representation ( CBOR ) [RFC8949] , as defined in [FIDO-CTAP] . CDDL This specification describes the syntax of all CBOR -encoded data using the CBOR Data Definition Language ( CDDL ) [RFC8610] . COSE CBOR Object Signing and Encryption (COSE) [RFC8152] . The IANA COSE Algorithms registry [IANA-COSE-ALGS-REG] established by this specification is also used. Credential Management The API described in this document is an extension of the Credential concept defined in [CREDENTIAL-MANAGEMENT-1] . DOM DOMException and the DOMException values used in this specification are defined in [DOM4] . ECMAScript %ArrayBuffer% is defined in [ECMAScript] . HTML The concepts of browsing context , origin , opaque origin , tuple origin , relevant settings object , and is a registrable domain suffix of or is equal to are defined in [HTML] . URL The concept of same site is defined in [URL] . Web IDL Many of the interface definitions and all of the IDL in this specification depend on [WebIDL] . This updated version of the Web IDL standard adds support for Promise s, which are now the preferred mechanism for asynchronous interaction in all new web APIs. FIDO AppID The algorithms for determining the FacetID of a calling application and determining if a caller’s FacetID is authorized for an AppID (used only in the AppID extension ) are defined by [FIDO-APPID] . The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119] . 4. Terminology Attestation Generally, attestation is a statement serving to bear witness, confirm, or authenticate. In the WebAuthn context, attestation is employed to attest to the provenance of an authenticator and the data it emits; including, for example: credential IDs , credential key pairs , signature counters, etc. An attestation statement is conveyed in an attestation object during registration . See also § 6.5 Attestation and Figure 6 . Whether or how the client conveys the attestation statement and AAGUID portions of the attestation object to the Relying Party is described by attestation conveyance . Attestation Certificate A X.509 Certificate for the attestation key pair used by an authenticator to attest to its manufacture and capabilities. At registration time, the authenticator uses the attestation private key to sign the Relying Party -specific credential public key (and additional data) that it generates and returns via the authenticatorMakeCredential operation. Relying Parties use the attestation public key conveyed in the attestation certificate to verify the attestation signature . Note that in the case of self attestation , the authenticator has no distinct attestation key pair nor attestation certificate , see self attestation for details. Authentication Authentication Ceremony The ceremony where a user, and the user’s client (containing at least one authenticator ) work in concert to cryptographically prove to a Relying Party that the user controls the credential private key of a previously-registered public key credential (see Registration ). Note that this includes a test of user presence or user verification . The WebAuthn authentication ceremony is defined in § 7.2 Verifying an Authentication Assertion , and is initiated by the Relying Party calling navigator.credentials.get() with a publicKey argument. See § 5 Web Authentication API for an introductory overview and § 1.3.3 Authentication for implementation examples. Authentication Assertion Assertion The cryptographically signed AuthenticatorAssertionResponse object returned by an authenticator as the result of an authenticatorGetAssertion operation. This corresponds to the [CREDENTIAL-MANAGEMENT-1] specification’s single-use credentials . Authenticator WebAuthn Authenticator A cryptographic entity, existing in hardware or software, that can register a user with a given Relying Party and later assert possession of the registered public key credential , and optionally verify the user , when requested by the Relying Party . Authenticators can report information regarding their type and security characteristics via attestation during registration . A WebAuthn Authenticator could be a roaming authenticator , a dedicated hardware subsystem integrated into the client device , or a software component of the client or client device . In general, an authenticator is assumed to have only one user. If multiple natural persons share access to an authenticator , they are considered to represent the same user in the context of that authenticator . If an authenticator implementation supports multiple users in separated compartments, then each compartment is considered a separate authenticator with a single user with no access to other users' credentials . Authorization Gesture An authorization gesture is a physical interaction performed by a user with an authenticator as part of a ceremony , such as registration or authentication . By making such an authorization gesture , a user provides consent for (i.e., authorizes ) a ceremony to proceed. This MAY involve user verification if the employed authenticator is capable, or it MAY involve a simple test of user presence . Biometric Recognition The automated recognition of individuals based on their biological and behavioral characteristics [ISOBiometricVocabulary] . Biometric Authenticator Any authenticator that implements biometric recognition . Bound credential A public key credential source or public key credential is said to be bound to its managing authenticator . This means that only the managing authenticator can generate assertions for the public key credential sources bound to it. Ceremony The concept of a ceremony [Ceremony] is an extension of the concept of a network protocol, with human nodes alongside computer nodes and with communication links that include user interface(s), human-to-human communication, and transfers of physical objects that carry data. What is out-of-band to a protocol is in-band to a ceremony. In this specification, Registration and Authentication are ceremonies, and an authorization gesture is often a component of those ceremonies . Client WebAuthn Client Also referred to herein as simply a client . See also Conforming User Agent . A WebAuthn Client is an intermediary entity typically implemented in the user agent (in whole, or in part). Conceptually, it underlies the Web Authentication API and embodies the implementation of the [[Create]](origin, options, sameOriginWithAncestors) and [[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors) internal methods . It is responsible for both marshalling the inputs for the underlying authenticator operations , and for returning the results of the latter operations to the Web Authentication API 's callers. The WebAuthn Client runs on, and is distinct from, a WebAuthn Client Device . Client Device WebAuthn Client Device The hardware device on which the WebAuthn Client runs, for example a smartphone, a laptop computer or a desktop computer, and the operating system running on that hardware. The distinctions between a WebAuthn Client device and a client are: a single client device MAY support running multiple clients , i.e., browser implementations, which all have access to the same authenticators available on that client device , and platform authenticators are bound to a client device rather than a WebAuthn Client . A client device and a client together constitute a client platform . Client Platform A client device and a client together make up a client platform . A single hardware device MAY be part of multiple distinct client platforms at different times by running different operating systems and/or clients . Client-Side This refers in general to the combination of the user’s client platform , authenticators , and everything gluing it all together. Client-side discoverable Public Key Credential Source Client-side discoverable Credential Discoverable Credential [DEPRECATED] Resident Credential [DEPRECATED] Resident Key Note: Historically, client-side discoverable credentials have been known as resident credentials or resident keys . Due to the phrases ResidentKey and residentKey being widely used in both the WebAuthn API and also in the Authenticator Model (e.g., in dictionary member names, algorithm variable names, and operation parameters) the usage of resident within their names has not been changed for backwards compatibility purposes. Also, the term resident key is defined here as equivalent to a client-side discoverable credential . A Client-side discoverable Public Key Credential Source , or Discoverable Credential for short, is a public key credential source that is discoverable and usable in authentication ceremonies where the Relying Party does not provide any credential ID s, i.e., the Relying Party invokes navigator.credentials.get() with an empty allowCredentials argument. This means that the Relying Party does not necessarily need to first identify the user. As a consequence, a discoverable credential capable authenticator can generate an assertion signature for a discoverable credential given only an RP ID , which in turn necessitates that the public key credential source is stored in the authenticator or client platform . This is in contrast to a Server-side Public Key Credential Source , which requires that the authenticator is given both the RP ID and the credential ID but does not require client-side storage of the public key credential source . See also: client-side credential storage modality and non-discoverable credential . Note: Client-side discoverable credentials are also usable in authentication ceremonies where credential ID s are given, i.e., when calling navigator.credentials.get() with a non- empty allowCredentials argument. Conforming User Agent A user agent implementing, in cooperation with the underlying client device , the Web Authentication API and algorithms given in this specification, and handling communication between authenticators and Relying Parties . Credential ID A probabilistically-unique byte sequence identifying a public key credential source and its authentication assertions . Credential IDs are generated by authenticators in two forms: At least 16 bytes that include at least 100 bits of entropy, or The public key credential source , without its Credential ID or mutable items , encrypted so only its managing authenticator can decrypt it. This form allows the authenticator to be nearly stateless, by having the Relying Party store any necessary state. Note: [FIDO-UAF-AUTHNR-CMDS] includes guidance on encryption techniques under \"Security Guidelines\". Relying Parties do not need to distinguish these two Credential ID forms. Credential Key Pair Credential Private Key Credential Public Key User Public Key A credential key pair is a pair of asymmetric cryptographic keys generated by an authenticator and scoped to a specific WebAuthn Relying Party . It is the central part of a public key credential . A credential public key is the public key portion of a credential key pair . The credential public key is returned to the Relying Party during a registration ceremony . A credential private key is the private key portion of a credential key pair . The credential private key is bound to a particular authenticator - its managing authenticator - and is expected to never be exposed to any other party, not even to the owner of the authenticator . Note that in the case of self attestation , the credential key pair is also used as the attestation key pair , see self attestation for details. Note: The credential public key is referred to as the user public key in FIDO UAF [UAFProtocol] , and in FIDO U2F [FIDO-U2F-Message-Formats] and some parts of this specification that relate to it. Credential Properties A credential property is some characteristic property of a public key credential source , such as whether it is a client-side discoverable credential or a server-side credential . Human Palatability An identifier that is human-palatable is intended to be rememberable and reproducible by typical human users, in contrast to identifiers that are, for example, randomly generated sequences of bits [EduPersonObjectClassSpec] . Non-Discoverable Credential This is a credential whose credential ID must be provided in allowCredentials when calling navigator.credentials.get() because it is not client-side discoverable . See also server-side credentials . Public Key Credential Source A credential source ( [CREDENTIAL-MANAGEMENT-1] ) used by an authenticator to generate authentication assertions . A public key credential source consists of a struct with the following items : type whose value is of PublicKeyCredentialType , defaulting to public-key . id A Credential ID . privateKey The credential private key . rpId The Relying Party Identifier , for the Relying Party this public key credential source is scoped to. userHandle The user handle associated when this public key credential source was created. This item is nullable. otherUI OPTIONAL other information used by the authenticator to inform its UI. For example, this might include the user’s displayName . otherUI is a mutable item and SHOULD NOT be bound to the public key credential source in a way that prevents otherUI from being updated. The authenticatorMakeCredential operation creates a public key credential source bound to a managing authenticator and returns the credential public key associated with its credential private key . The Relying Party can use this credential public key to verify the authentication assertions created by this public key credential source . Public Key Credential Generically, a credential is data one entity presents to another in order to authenticate the former to the latter [RFC4949] . The term public key credential refers to one of: a public key credential source , the possibly- attested credential public key corresponding to a public key credential source , or an authentication assertion . Which one is generally determined by context. Note: This is a willful violation of [RFC4949] . In English, a \"credential\" is both a) the thing presented to prove a statement and b) intended to be used multiple times. It’s impossible to achieve both criteria securely with a single piece of data in a public key system. [RFC4949] chooses to define a credential as the thing that can be used multiple times (the public key), while this specification gives \"credential\" the English term’s flexibility. This specification uses more specific terms to identify the data related to an [RFC4949] credential: \"Authentication information\" (possibly including a private key) Public key credential source \"Signed value\" Authentication assertion [RFC4949] \"credential\" Credential public key or attestation object At registration time, the authenticator creates an asymmetric key pair, and stores its private key portion and information from the Relying Party into a public key credential source . The public key portion is returned to the Relying Party , who then stores it in conjunction with the present user’s account. Subsequently, only that Relying Party , as identified by its RP ID , is able to employ the public key credential in authentication ceremonies , via the get() method. The Relying Party uses its stored copy of the credential public key to verify the resultant authentication assertion . Rate Limiting The process (also known as throttling) by which an authenticator implements controls against brute force attacks by limiting the number of consecutive failed authentication attempts within a given period of time. If the limit is reached, the authenticator should impose a delay that increases exponentially with each successive attempt, or disable the current authentication modality and offer a different authentication factor if available. Rate limiting is often implemented as an aspect of user verification . Registration Registration Ceremony The ceremony where a user, a Relying Party , and the user’s client (containing at least one authenticator ) work in concert to create a public key credential and associate it with the user’s Relying Party account. Note that this includes employing a test of user presence or user verification . After a successful registration ceremony , the user can be authenticated by an authentication ceremony . The WebAuthn registration ceremony is defined in § 7.1 Registering a New Credential , and is initiated by the Relying Party calling navigator.credentials.create() with a publicKey argument. See § 5 Web Authentication API for an introductory overview and § 1.3.1 Registration for implementation examples. Relying Party See WebAuthn Relying Party . Relying Party Identifier RP ID In the context of the WebAuthn API , a relying party identifier is a valid domain string identifying the WebAuthn Relying Party on whose behalf a given registration or authentication ceremony is being performed. A public key credential can only be used for authentication with the same entity (as identified by RP ID ) it was registered with. By default, the RP ID for a WebAuthn operation is set to the caller’s origin 's effective domain . This default MAY be overridden by the caller, as long as the caller-specified RP ID value is a registrable domain suffix of or is equal to the caller’s origin 's effective domain . See also § 5.1.3 Create a New Credential - PublicKeyCredential’s [[Create]](origin, options, sameOriginWithAncestors) Method and § 5.1.4 Use an Existing Credential to Make an Assertion - PublicKeyCredential’s [[Get]](options) Method . Note: An RP ID is based on a host 's domain name. It does not itself include a scheme or port , as an origin does. The RP ID of a public key credential determines its scope . I.e., it determines the set of origins on which the public key credential may be exercised , as follows: The RP ID must be equal to the origin 's effective domain , or a registrable domain suffix of the origin 's effective domain . The origin 's scheme must be https . The origin 's port is unrestricted. For example, given a Relying Party whose origin is https://login.example.com:1337 , then the following RP ID s are valid: login.example.com (default) and example.com , but not m.login.example.com and not com . This is done in order to match the behavior of pervasively deployed ambient credentials (e.g., cookies, [RFC6265] ). Please note that this is a greater relaxation of \"same-origin\" restrictions than what document.domain 's setter provides. These restrictions on origin values apply to WebAuthn Clients . Other specifications mimicking the WebAuthn API to enable WebAuthn public key credentials on non-Web platforms (e.g. native mobile applications), MAY define different rules for binding a caller to a Relying Party Identifier . Though, the RP ID syntaxes MUST conform to either valid domain strings or URIs [RFC3986] [URL] . Server-side Public Key Credential Source Server-side Credential [DEPRECATED] Non-Resident Credential Note: Historically, server-side credentials have been known as non-resident credentials . For backwards compatibility purposes, the various WebAuthn API and Authenticator Model components with various forms of resident within their names have not been changed. A Server-side Public Key Credential Source , or Server-side Credential for short, is a public key credential source that is only usable in an authentication ceremony when the Relying Party supplies its credential ID in navigator.credentials.get() 's allowCredentials argument. This means that the Relying Party must manage the credential’s storage and discovery, as well as be able to first identify the user in order to discover the credential IDs to supply in the navigator.credentials.get() call. Client-side storage of the public key credential source is not required for a server-side credential . This is in contrast to a client-side discoverable credential , which instead does not require the user to first be identified in order to provide the user’s credential ID s to a navigator.credentials.get() call. See also: server-side credential storage modality and non-discoverable credential . Test of User Presence A test of user presence is a simple form of authorization gesture and technical process where a user interacts with an authenticator by (typically) simply touching it (other modalities may also exist), yielding a Boolean result. Note that this does not constitute user verification because a user presence test , by definition, is not capable of biometric recognition , nor does it involve the presentation of a shared secret such as a password or PIN. User Consent User consent means the user agrees with what they are being asked, i.e., it encompasses reading and understanding prompts. An authorization gesture is a ceremony component often employed to indicate user consent . User Handle The user handle is specified by a Relying Party , as the value of user . id , and used to map a specific public key credential to a specific user account with the Relying Party . Authenticators in turn map RP ID s and user handle pairs to public key credential sources . A user handle is an opaque byte sequence with a maximum size of 64 bytes, and is not meant to be displayed to the user. User Verification The technical process by which an authenticator locally authorizes the invocation of the authenticatorMakeCredential and authenticatorGetAssertion operations. User verification MAY be instigated through various authorization gesture modalities; for example, through a touch plus pin code, password entry, or biometric recognition (e.g., presenting a fingerprint) [ISOBiometricVocabulary] . The intent is to distinguish individual users. Note that user verification does not give the Relying Party a concrete identification of the user, but when 2 or more ceremonies with user verification have been done with that credential it expresses that it was the same user that performed all of them. The same user might not always be the same natural person, however, if multiple natural persons share access to the same authenticator . Note: Distinguishing natural persons depends in significant part upon the client platform 's and authenticator 's capabilities. For example, some devices are intended to be used by a single individual, yet they may allow multiple natural persons to enroll fingerprints or know the same PIN and thus access the same Relying Party account(s) using that device. Note: Invocation of the authenticatorMakeCredential and authenticatorGetAssertion operations implies use...",
  "summary": "# WebAuthn Specification Summary\n\n## Overview\nThe W3C Web Authentication (WebAuthn) specification defines an API for creating and using strong, attested, scoped public key-based credentials for web application user authentication.\n\n## Main Topics and Key Concepts\n\n### Core Components\n- **PublicKeyCredential**: Extends the Credential Management API\n- **WebAuthn Authenticator**: Creates and stores public key credentials\n- **Relying Party**: The web application/service requesting authentication\n- **User Agent**: The browser implementing the WebAuthn API\n\n### Two Main Ceremonies\n1. **Registration**: Creates a public key credential on an authenticator, scoped to a Relying Party and user account\n2. **Authentication**: Relying Party receives an Authentication Assertion proving user presence and consent\n\n### Authenticator Types\n- **Platform Authenticators**: Implemented on-device (built-in fingerprint sensors, face recognition)\n- **Roaming Authenticators**: External devices accessed via:\n  - USB (Universal Serial Bus)\n  - BLE (Bluetooth Low Energy)\n  - NFC (Near Field Communications)\n\n### Authenticator Implementation Locations\n- General-purpose computing device (software)\n- On-device Secure Execution Environment\n- Trusted Platform Module (TPM)\n- Secure Element (SE)\n- Off-device (roaming)\n\n## API Endpoints/Methods\n- `navigator.credentials.create()` - Used during Registration\n- `navigator.credentials.get()` - Used during Authentication\n\n## Key Security Properties\n- **Scoped Credentials**: Public key credentials can only be accessed by origins belonging to the Relying Party that created them\n- **Privacy Across Relying Parties**: RPs cannot detect properties or existence of credentials scoped to other RPs\n- **Enforcement**: Scoping enforced jointly by User Agents and authenticators\n\n## Specification Sections by Audience\n\n| Audience | Relevant Sections |\n|----------|-------------------|\n| Relying Party developers | §7 (RP Operations), §6.5 (Attestation), §8 (Attestation Formats), §13.4 & §14.6 (Security/Privacy) |\n| User Agent developers | §5 (Web Auth API), §9 (Extensions), §14.5 (Privacy) |\n| Authenticator developers | §6 (Authenticator Model), §8, §9, §10, §13.3, §14.4 |\n| All audiences | §1.2 (Use Cases), §1.3 (Sample Scenarios), §4 (Terminology) |\n\n## Use Case Scenarios\n\n### Registration Flow (Mobile)\n1. User navigates to site, signs in or creates account\n2. Device prompts to register with the site\n3. User provides authorization gesture (PIN, biometric)\n4. Registration completes\n\n### Authentication Flow (Cross-Device)\n1. User pairs phone with laptop via Bluetooth\n2. User initiates sign-in on laptop browser\n3. Browser prompts to complete action on phone\n4. Phone shows identity selection\n5. User selects identity and provides authorization gesture\n6. Laptop shows signed-in state\n\n### New Device Registration\n- Combines roaming authenticator (USB security key) with platform authenticator (fingerprint sensor)\n- Roaming authenticator used for new/unknown devices\n- Platform authenticator provides low-friction re-authentication on known devices\n- **Note**: This approach also useful for account recovery\n\n## Best Practices/Recommendations\n- All audiences should understand the role of each component (Relying Party server, client, authenticator)\n- Review Security Considerations (§13) and Privacy Considerations (§14) sections\n- Reference [WebAuthnAPIGuide] for overall tutorial\n- Register multiple authenticators for account recovery scenarios\n\n## External References\n- [CREDENTIAL-MANAGEMENT-1] - Credential Management API specification\n- [WebAuthnAPIGuide] - Tutorial documentation",
  "referencedFrom": [
    "configuration/account-security.mdx"
  ],
  "cachedAt": "2025-12-20T09:27:05.512Z",
  "contentLength": 50003,
  "summaryLength": 3623,
  "model": "claude-opus-4-5-20251101"
}